 package{	import flash.display.*;	import flash.geom.*;	import flash.net.*;	import flash.ui.*;	import flash.events.*;	import flash.text.*;	import flash.utils.*;	import flash.filters.GlowFilter;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundTransform;		public class BrickBreaker extends MovieClip	{		// Text and text related		private var score_text:TextField;		private var lives_text:TextField;		private var level_text:TextField;		private var top_text_format:TextFormat = new TextFormat();		private var level_header_text:TextField;		private var level_name_text:TextField;		private var game_over_text:TextField;				private var level_header_text_format:TextFormat = new TextFormat();		private var level_name_text_format:TextFormat = new TextFormat();		private var level_font:Font = new feedback_font();		private var one_up:TextField;				private var one_up_font:Font = new extra_life_font();		private var level_pad:Shape;		private var display_level_header_text:String;		private var display_level_pad:Boolean;				private var currentScore:uint;		private var current_lives:uint;				// paddle related		private var bat:Sprite;		private var batWidth:Number;		private var batHeight:Number;				// ball related		private var ball:Shape;		private var ballRadius:Number;		private var ball_x_velocity:Number = 1;		private var ball_y_velocity:Number = 1;		private var ball_served:Boolean = false;				private var number_of_hits:int = 0;		private var level_speed:int;		private var ball_speed:int;		private var number_per_speed_increase:int;		private var ball_max_speed:int;				// brick related		private var bricks:Array;		private var brickWidth:int;		private var brickHeight:int;		private var line_style_list:Array;		private var numBricks:uint;		private var real_number_of_bricks:int;		private var brick_x_start:int;		private var brick_y_start:int;		private var bricks_per_row:int;		private var maximum_bricks_per_row:int;		private var future_bricks_to_fade_out:Array = new Array;		private var bricks_to_fade_out:Array = new Array;		private var bricks_to_fade_in:Array = new Array;		private var future_bricks_to_fade_in:Array = new Array;		private var future_regenerate_list:Array = new Array;		private var regenerate_list:Array = new Array;		private var should_fade_out:Boolean;		private var should_fade_in:Boolean;		private var last_brick_row:int;		private var should_regenerate:Boolean;		private var freeze_regeneration:Boolean = false;							// play area size & environment		private var playfieldWidth:uint = 640;		private var playfieldHeight:uint = 480;		private var wall_one:Shape;			private var wall_two:Shape;		private var ceiling_top:Shape;		private var ceiling_floor:Shape;		private var ceiling:int = 25 + wall_width;		private	var ceiling_height:int;		private var wall_width:int = 10;				// levels & lives		private var level:int = 1;		private var max_levels:int = 11;		private var number_of_lives:uint = 5;		private var level_complete:Boolean = false;				// guide		private var guide:Shape;		private var guide_radius:Number;			// key input related		private var key_pressed:Boolean = false;		private var key_number:int;		private var bat_key_move:int = 10;		// misc		private var my_pi:Number = Math.PI;				private var game_over:Boolean = false;		private var player_died:Boolean = false;		private var last_control_left:Boolean = true;		private var extra_life_track:int = 5000;		private var display_one_up:Boolean = false;				// effects		private var glow:GlowFilter=new GlowFilter();				// audio				private var channel:SoundChannel;		private var wall_channel:SoundChannel;		private var brick_channel:SoundChannel;		private var level_paddle_sounds:Array;		private var level_brick_sounds:Array;		private var level_wall_sounds:Array;		private var level_death_sounds:Array;		private var level_serve_sounds:Array;		private var level_extra_life_sounds:Array;		private var active_brick_sounds:Array;		// streaming sounds				private var invaders_ambience_sound:Sound;		private var beach_ambience_sound:Sound;		private var recognizer_ambience_sound:Sound;		private var applause_sound:Sound;				// finale		private var finale_activated:Boolean = false;				public function BrickBreaker()		{			//streaming sound paths are set via flashvars			var paramObj:Object = LoaderInfo(this.root.loaderInfo).parameters;						invaders_ambience_sound = new Sound(new URLRequest(paramObj["invaders"]));			beach_ambience_sound = new Sound(new URLRequest(paramObj["beach"]));			recognizer_ambience_sound = new Sound(new URLRequest(paramObj["recognizer"]));						applause_sound = new Sound(new URLRequest(paramObj["applause"]));			// set up text			score_text = new TextField();			lives_text = new TextField();			level_text = new TextField();			level_header_text = new TextField();			level_name_text = new TextField();			one_up = new TextField();			game_over_text = new TextField();			score_text.textColor = lives_text.textColor = level_text.textColor = level_header_text.textColor = level_name_text.textColor = one_up.textColor = game_over_text.textColor = 0xffffff; // white text			score_text.x = 50;			lives_text.x = 300;			level_text.x = 550;						score_text.y = lives_text.y = level_text.y = wall_width + 2;			level_header_text.y = 250;			level_name_text.y = 275;			game_over_text.y = 275;									currentScore = 0;			score_text.autoSize = TextFieldAutoSize.LEFT;			lives_text.autoSize = TextFieldAutoSize.LEFT;			level_text.autoSize = TextFieldAutoSize.LEFT;			game_over_text.autoSize = TextFieldAutoSize.LEFT;			level_header_text.autoSize = TextFieldAutoSize.LEFT;			level_name_text.autoSize = TextFieldAutoSize.LEFT;					top_text_format.size = 11;			top_text_format.font = level_font.fontName;						addChild(score_text);			addChild(lives_text);			addChild(level_text);						// Create the player's bat and add it			bat = new Sprite();			batWidth = 65;			batHeight = 10;			bat.graphics.lineStyle(1,0);					bat.graphics.beginGradientFill(GradientType.LINEAR, [0x3841ff, 0x000000], [1, 1], [120, 150]);			bat.graphics.drawRect(-batHeight/2, -batWidth/2, batHeight ,batWidth); // draw bat with origin at the center			bat.graphics.endFill();						bat.rotation = 90;			bat.x = playfieldWidth/2;			bat.y = playfieldHeight-batHeight;			// add as child					addChild(bat);								// add listener for frame refresh (based on movie frame rate)			addEventListener( Event.ENTER_FRAME, handleUpdate );			// add listener for mouse movement			stage.addEventListener( MouseEvent.MOUSE_MOVE, handleMouseMove );			// add listener for keyboard input			stage.addEventListener( KeyboardEvent.KEY_DOWN, handleKeyDown );			stage.addEventListener( KeyboardEvent.KEY_UP, handleKeyUp );			// Add any other required initialization			stage.addEventListener( MouseEvent.CLICK, handleClick);						// Mouse.hide();			current_lives = number_of_lives;			createLevel(level);				}				private function handleMouseMove(e:MouseEvent):void		{			var mX:int = mouseX;			moveBat(mX);		}				private function handleClick(e:MouseEvent):void		{			if (game_over)			{				clearBricks();				level = 1;				createLevel(level);			}			else			{				if (!ball_served && ball.alpha == 1)				{					serveBall();				}			}		}		private function moveBat(x_position)		{			var bat_limit_left:int = wall_one.x + (wall_width / 2);			var bat_limit_right:int = wall_two.x - (wall_width / 2);									// if ball is larger than bat change paddle limits			if (!ball_served && ballRadius > (batWidth / 2))			{				bat_limit_left += ballRadius;				bat_limit_right -= ballRadius;			}			else			{				bat_limit_left += batWidth / 2;				bat_limit_right -= batWidth / 2;			}						if (!ball_served && x_position > bat.x)			{				last_control_left = false;			}			else if (!ball_served && x_position < bat.x)			{				last_control_left = true;			}			if (x_position > bat_limit_right) 			{				bat.x = bat_limit_right;			}			else if (x_position < bat_limit_left)			{				bat.x = bat_limit_left;			}			else 			{				bat.x = x_position;			}						if (!ball_served)			{				addGuideToPaddle();			}		}				private function handleKeyDown( e:KeyboardEvent ):void		{			// separate key function "keyboardUpdate" was required to fix keypress delay			key_number = e.keyCode;			key_pressed = true;							if (key_number == Keyboard.UP)				{					current_lives++;					updateTopText();				}								else if (key_number == Keyboard.ENTER && game_over)				{					clearBricks();					createLevel(level);				}							else if (key_number == Keyboard.SPACE)				{					if (game_over)					{						clearBricks();						level = 1;						createLevel(level);					}					else if (!ball_served && ball.alpha == 1)					{						serveBall();					}				}								else if (key_number == Keyboard.PAGE_DOWN)				{					if (level > 1)					{						level--;						removeLevelText();						clearBricks();						createLevel(level);					}				}								else if (key_number == Keyboard.PAGE_UP)				{						removeLevelText();						clearBricks();						level_complete = true;				}		}				private function keyboardUpdate()		{			if (key_pressed)			{				var key_x:int;								if (key_number == Keyboard.LEFT)				{					key_x = bat.x - bat_key_move;					moveBat(key_x);				}				else if (key_number == Keyboard.RIGHT)				{					key_x = bat.x + bat_key_move;					moveBat(key_x);				}			}		}		private function handleKeyUp( e:KeyboardEvent ):void		{			key_pressed = false;		}				private function handleUpdate(e:Event):void		{			keyboardUpdate();			if (level_complete)			{				level++;				if (!finale_activated && level > max_levels)				{					finale();				}				else				{					createLevel(level);					ball_served = false;				}			}			if (should_fade_out)			{				fadeBricksOut();			}			else			{				if (future_bricks_to_fade_out.length > 0)				{					bricks_to_fade_out = bricks_to_fade_out.concat(future_bricks_to_fade_out);					future_bricks_to_fade_out = new Array;					should_fade_out = true;				}							if (should_fade_in)				{					fadeBricksIn();				}				else				{					if (future_regenerate_list.length > 0)					{						regenerate_list = regenerate_list.concat(future_regenerate_list);						future_regenerate_list = new Array;					}										if (should_regenerate && !freeze_regeneration && regenerate_list.length > 0)					{						freeze_regeneration = true;						var regenerate_time = 15000+((Math.random()*15)*1000)						var timer:Timer = new Timer(regenerate_time, 1);						timer.addEventListener(TimerEvent.TIMER, regenerateBricks);						timer.start();					}				}						}						if (display_level_header_text)			{				displayLevelText();			}						if (display_one_up)			{				oneUp();			}					if (ball_served && !player_died)			{				ballMotion();				ballBounceScan();			}			else if (ball_served && player_died)			{				if (playerExperiencesDeath())				{					if (current_lives > 0)					{						ball_served = false;						player_died = false;						ball.y = bat.y - batHeight / 2 - ballRadius;						ball_speed = level_speed;					}					else // remove ball on game over					{						if (ball && parent.contains(ball))						{							removeChild(ball);						}					}				}			}			else // waiting to serve the ball...			{				if (ball.alpha != 1)				{					ball.alpha = 1;				}				ball.x = bat.x;			}		}				private function regenerateBricks(e:TimerEvent):void 		{			// 50% chance of regeneration			var my_random_number:int = Math.random()*2;			if (my_random_number == 1)			{				var number_of_bricks:int = (Math.random()*(regenerate_list.length))+1;				var brick_index:int;				var the_brick:Sprite;				while (bricks_to_fade_in.length < number_of_bricks)				{					// add chosen bricks to be faded in					brick_index = Math.random()*(regenerate_list.length);										the_brick = regenerate_list[brick_index];						// remove from regenerate list					regenerate_list.splice(brick_index,1);					bricks_to_fade_in.push(the_brick);										brick_index++;				}								should_fade_in = true;			}			else			{				freeze_regeneration = false;			}		}		private function fadeBricksIn()		{			var the_brick:Sprite;			var all_faded:int = 0;			for (var brick_index in bricks_to_fade_in)			{				the_brick = bricks_to_fade_in[brick_index];								// color the brick and display it				if (!parent.contains(the_brick))					{						the_brick.graphics.beginFill(0xff0000);							the_brick.graphics.drawRect(-brickHeight/2, -brickWidth/2, brickHeight, brickWidth);						the_brick.graphics.endFill();						addChildAt(the_brick,1);					}				if (the_brick.alpha < 1)				{					the_brick.alpha += .1;				}				else				{					all_faded++;					bricks.push(the_brick);				}			}						if (all_faded == bricks_to_fade_in.length)			{				freeze_regeneration = false;				should_fade_in = false;				bricks_to_fade_in = new Array;			}				}						private function serveBall()		{			guide.alpha = 0;			ball_x_velocity = (Math.random()*.85)+.15;			ball_x_velocity = 1;			ball_y_velocity = 1;			ball_speed = level_speed;			ball_served = true;			ball_y_velocity = -(Math.abs(ball_y_velocity));			ball_x_velocity = last_control_left ? -(Math.abs(ball_x_velocity)) : Math.abs(ball_x_velocity);			level_serve_sounds[randomSound(level_serve_sounds)].play(0,0)					}				private function ballMotion()		{			var speed_scale:Number = getBallSpeed();			ball.x += ball_x_velocity * speed_scale;			ball.y += ball_y_velocity * speed_scale;					//ball.x = mouseX;		//ball.y = mouseY;		}				private function getBallSpeed()		{			var current_speed:Number = Math.sqrt(ball_x_velocity * ball_x_velocity + ball_y_velocity * ball_y_velocity);			var speed_scale:Number = ball_speed / current_speed;			return speed_scale;		}				private function createGuide()		{			guide = new Shape();			guide_radius = 1;			guide.graphics.beginFill(0xff0000);					guide.graphics.drawCircle(0, 0, guide_radius);			guide.y = bat.y;			guide.alpha = 0;						if (!parent.contains(guide))			{				addChild(guide);			}						// add glow to guide			glow.color=0xFF0000;			glow.strength=3;			glow.inner=false;			glow.blurY=15;			glow.blurX=15;			guide.filters=[glow];		}				private function addGuideToPaddle()		{			if (last_control_left)			{				guide.x = bat.x - (batWidth / 2) + guide_radius +1;				}			else			{				guide.x = bat.x + (batWidth / 2) - guide_radius;			}			if (guide.alpha != 1)			{				guide.alpha = 1;			}		}				private function textEffect(text1, text2)		{			level_header_text.text = text1;			level_name_text.text = text2;			level_header_text_format.size = 14;			level_name_text_format.size = 18;			level_header_text_format.font = level_font.fontName;					level_name_text_format.font = level_font.fontName;								level_header_text.setTextFormat(level_header_text_format);			level_name_text.setTextFormat(level_name_text_format);			level_header_text.embedFonts = true;				level_name_text.embedFonts = true;			level_header_text.x = centerText(level_header_text);			level_name_text.x = centerText(level_name_text);						level_pad = new Shape();			level_pad.graphics.beginFill(0x000000);			level_pad.graphics.drawRoundRect((level_name_text.x) - 25, level_header_text.y - 10, (level_name_text.width) +50,level_name_text.height + level_header_text.height + 25, 36);			level_pad.graphics.endFill();						level_header_text.alpha = 0;			level_name_text.alpha = 0;			level_pad.alpha = 0;						if (!parent.contains(level_pad))			{												addChild(level_pad);			}			if (!parent.contains(level_header_text))			{				addChild(level_header_text);					}			if (!parent.contains(level_name_text))			{				addChild(level_name_text);				}					}		private function displayLevelText()		{			var alpha_step:Number = .025;						if (display_level_header_text == "fade_in" && level_header_text.alpha < 1)			{				level_header_text.alpha += alpha_step;				level_name_text.alpha += alpha_step;				if (display_level_pad)				{					level_pad.alpha += alpha_step / 2;				}			}			else if (display_level_header_text == "fade_in" && level_header_text.alpha >= 1)			{				display_level_header_text = null;				var timer:Timer = new Timer(5000, 1);				timer.addEventListener(TimerEvent.TIMER, textEffectTimer);				timer.start();			}			else if (display_level_header_text == "fade_out" && level_header_text.alpha > 0)			{				level_header_text.alpha -= alpha_step;				level_name_text.alpha -= alpha_step;				if (display_level_pad)				{					level_pad.alpha -= alpha_step / 2;				}			}			else			{				removeLevelText();				display_level_header_text = null;			}		}				private function textEffectTimer(e:TimerEvent):void		{			display_level_header_text = "fade_out";		}		private function removeLevelText()		{			if (game_over_text && parent.contains(game_over_text))			{				removeChild(game_over_text); 			}			if (level_header_text && parent.contains(level_header_text))			{				removeChild(level_header_text);			}			if (level_name_text && parent.contains(level_name_text))			{				removeChild(level_name_text);			}			if (level_pad && parent.contains(level_pad))			{				removeChild(level_pad);			}		}				private function centerText(text_object)		{			return ((wall_two.x + (wall_width / 2)) /2 ) - text_object.textWidth / 2;		}		private function clearBricks()		{			if (game_over_text && parent.contains(game_over_text))			{											   				removeChild(game_over_text);			}			if (guide && parent.contains(guide))			{				removeChild(guide);			}						ball_speed = level_speed;			ball_served = false;			player_died = false;			for (var brick in bricks)			{				if (bricks[brick] && parent.contains(bricks[brick]))				{					removeChild(bricks[brick]);				}			}			if (game_over)			{				game_over = false;				current_lives = number_of_lives;				currentScore = 0;			}		}				private function playerExperiencesDeath()		{			if (current_lives == 0)			{				if (!game_over)				{					removeLevelText();										var game_over_format:TextFormat = new TextFormat();										game_over_text.text = "GAME OVER";					game_over_format.size = 16;					game_over_format.letterSpacing = 10;					game_over_format.font = level_font.fontName;							game_over_text.setTextFormat(game_over_format);					game_over_text.x = centerText(game_over_text);										game_over = true;										if (channel)					{						channel.stop();					}										if (game_over_text && !parent.contains(game_over_text))					{						addChild(game_over_text);					}				}			}						// fade ball out as it goes off screen			if (ball.alpha > 0)				{					ball.y += 1;					ball.alpha -= .01;					return false;				}			else			{				return true;			}		}				private function getAngle(x1,y1,x2,y2)		{			var the_angle:Number = Math.atan2(y2-y1,x2-x1) * 180/my_pi;			//return Math.abs(the_angle % 90);			return Math.abs(the_angle);		}				private function angleScan(hit_brick_list)		{			var is_greater:Boolean;			var is_less:Boolean;						for (var brick in hit_brick_list)			{				// check if the_angle >= brick_angle				if (hit_brick_list[brick][1] >= hit_brick_list[brick][2])				{					is_greater = true;				}								// check if the_angle < brick_angle				if (hit_brick_list[brick][1] < hit_brick_list[brick][2])				{					is_less = true;				}								if (is_greater && is_less)				{					return true				}			}			return false;		}				private function ballBounceScan()		{			var x_circle:int;			var y_circle:int;			var should_reflect:Boolean = true;			var the_angle:Number;			var speed_scale:Number;			var ball_future_x:int;			var ball_future_y:int;			var score_check:int;			var the_brick:Sprite;			var row:int;			var brick_angle:Number;			var brick_id:int;			var hit_brick_list:Array = new Array;			var brick_id_list:Array = new Array;				// detect degrees around ball			for (var i:int = 0; i < 360; i += 18)			{				// get ball's x & y position in next frame								speed_scale = getBallSpeed();				ball_future_x = ball.x + (ball_x_velocity * speed_scale);				ball_future_y = ball.y + (ball_y_velocity * speed_scale);						x_circle = (Math.cos(i * my_pi / 180) * ballRadius) + ball_future_x;				y_circle = (Math.sin(i * my_pi / 180) * ballRadius) + ball_future_y;								// bounce off of walls and ceiling							if (should_reflect && x_circle <= (wall_one.x + wall_width / 2))				{					ball_x_velocity = -(ball_x_velocity);					should_reflect = false					ballSpeedAdvance("left_wall");				}				else if (should_reflect && x_circle >= (wall_two.x - wall_width / 2))				{					ball_x_velocity = -ball_x_velocity;					should_reflect = false					ballSpeedAdvance("right_wall");				}				else if (should_reflect && y_circle <= ceiling + (wall_width / 2))  				{					ball_y_velocity = Math.abs(ball_y_velocity);					should_reflect = false;					ballSpeedAdvance("ceiling");				}									// bounce off of paddle or die!										if (should_reflect && y_circle >= bat.y - batHeight / 2)				{					if (x_circle >= bat.x  && x_circle <= bat.x + batWidth / 2)					{						ball_x_velocity = (x_circle - bat.x) / 12;						ball_y_velocity = -(Math.abs(ball_y_velocity));						should_reflect = false;						ballSpeedAdvance("paddle");					}					else if (x_circle <= bat.x && x_circle >= bat.x - batWidth / 2)					{						ball_x_velocity = -((bat.x - x_circle) / 12);						ball_y_velocity = -(Math.abs(ball_y_velocity));						should_reflect = false;						ballSpeedAdvance("paddle");					}											else if (y_circle > playfieldHeight && !player_died)					{						level_death_sounds[randomSound(level_death_sounds)].play(0,0);						player_died = true;						current_lives--;						updateTopText();										break;					}				}				// bounce off of bricks									for (var brick in bricks)				{					if (brick_id_list.indexOf(brick) == -1)					{						if (x_circle >= bricks[brick].x - (brickWidth / 2) && x_circle <= bricks[brick].x + (brickWidth / 2) && y_circle >= bricks[brick].y - (brickHeight / 2) && y_circle <= bricks[brick].y + (brickHeight /2) )						{							brick_id_list.push(brick);							// to determine if ball has hit side of brick or not							the_angle = Math.abs(Math.atan((bricks[brick].y - ball.y) / (ball.x - bricks[brick].x)) * 180 / my_pi);							brick_angle = Math.atan(brickHeight / brickWidth) * 180/my_pi;							hit_brick_list.push([bricks[brick],the_angle,brick_angle]);						}					}				}			} // end of 360 degree check							if (hit_brick_list.length > 0)				{					/* still working on this...										// if ball hits two bricks one's side and the other's top/bottom then reverse X & Y					if (hit_brick_list.length > 1 && angleScan(hit_brick_list))					{						ball_x_velocity = -ball_x_velocity;						ball_y_velocity = -ball_y_velocity;					}					else					{ */															// get angles of first hit brick					the_angle = hit_brick_list[0][1];					brick_angle = hit_brick_list[0][2];										if (the_angle >= brick_angle)					{						ball_y_velocity = -ball_y_velocity;					}					else if (the_angle < brick_angle)					{						ball_x_velocity = -ball_x_velocity;					}														//}							for (var hit_brick in hit_brick_list)					{						the_brick = hit_brick_list[hit_brick][0];						brick_id = bricks.indexOf(the_brick);												ballSpeedAdvance("brick");						row = (numBricks / bricks_per_row) - (brick / bricks_per_row) + 1;							var my_bit_map:BitmapData = new BitmapData(brickWidth, brickHeight, true, 0);						my_bit_map.draw(the_brick);						var my_color:uint = my_bit_map.getPixel(5,5);							if (my_color == 0xffffff)						{							the_brick.graphics.beginFill(0x1929ff);							}						else						{							the_brick.graphics.beginFill(0xffffff);										}						if (line_style_list)						{							the_brick.graphics.lineStyle(1,0x000000);						}						the_brick.graphics.drawRect(-brickHeight/2, -brickWidth/2, brickHeight, brickWidth);						the_brick.graphics.endFill();												// prevent additional bricks from being added to the lists if fade is in process						if (should_fade_out && bricks_to_fade_out.length > 0)						{							future_bricks_to_fade_out.push(the_brick);						}						else						{							bricks_to_fade_out.push(the_brick);						}												if (should_regenerate)						{							if (freeze_regeneration)							{								future_regenerate_list.push(the_brick);							}							else							{								regenerate_list.push(the_brick);							}						}												currentScore += 25 * row;						updateTopText();												score_check = currentScore / extra_life_track;												if (score_check == 1)						{							extra_life_track += (extra_life_track * 2);							current_lives++;							updateTopText();							level_extra_life_sounds[randomSound(level_extra_life_sounds)].play(0,0)							one_up.x = the_brick.x;							one_up.y = the_brick.y;							one_up.text = "1up";							if (one_up && !parent.contains(one_up))							{								addChild(one_up);							}							var one_up_format:TextFormat = new TextFormat();							one_up_format.size = 14;							one_up_format.font = one_up_font.fontName;									one_up.setTextFormat(one_up_format);							one_up.embedFonts = true;								one_up.alpha = 1;															display_one_up = true;						}												bricks.splice(brick_id,1);										}												}								hit_brick_list = new Array;								if (should_regenerate && bricks.length <= (real_number_of_bricks / 2))			{				should_regenerate = false;			}													if (!should_fade_out && bricks_to_fade_out.length > 0)			{				var timer:Timer = new Timer(100, 1);				timer.addEventListener(TimerEvent.TIMER, fadeBrickDelay);				timer.start();			}				 		}				private function fadeBrickDelay(e:TimerEvent):void 		{ 			should_fade_out = true;		}				private function fadeBricksOut()		{	if (bricks.length == 0)			{				ball.alpha -= .1;			}			for (var the_brick in bricks_to_fade_out)			{				if (bricks_to_fade_out[the_brick].alpha > 0)				{					bricks_to_fade_out[the_brick].alpha -= .1;				}				else				{										if (parent.contains(bricks_to_fade_out[the_brick]))					{						removeChild(bricks_to_fade_out[the_brick]);					}					bricks_to_fade_out.splice(the_brick,1);					if (bricks_to_fade_out.length == 0)					{						should_fade_out = false;						if (bricks.length == 0 && future_bricks_to_fade_out.length == 0)						{							level_complete = true;						}					}				}			}		}				private function ballSpeedAdvance(the_obj)		{			if (the_obj == "paddle")			{				level_paddle_sounds[randomSound(level_paddle_sounds)].play(0,0)				number_of_hits += 2;			}			else if (the_obj == "brick")			{				var brick_sound:int = randomSound(level_brick_sounds);				// to avoid the same audio file from playing ontop of itself				if (active_brick_sounds.indexOf(level_brick_sounds[brick_sound]) == -1 || (brick_channel && brick_channel.position > 50 ))				{					active_brick_sounds.push(level_brick_sounds[brick_sound]);										brick_channel = level_brick_sounds[brick_sound].play(0,0)					brick_channel.addEventListener(Event.SOUND_COMPLETE, brickSoundComplete);				}				number_of_hits++;			}						else if (the_obj == "left_wall" || the_obj == "right_wall" || the_obj == "ceiling")			{								wall_channel = level_wall_sounds[randomSound(level_wall_sounds)].play(0,0);								if (the_obj == "left_wall")				{					setPan(-1);				}				else if (the_obj == "right_wall")				{					setPan(1);				}				else				{					setPan(0);				}			}						if (number_of_hits > number_per_speed_increase && ball_speed < ball_max_speed)			{				ball_speed++;				number_of_hits = 0;			}		}				private function randomSound(the_sounds)		{			if (the_sounds.length > 1)			{				return (Math.round(Math.random()*(the_sounds.length-1)));			}			else			{				return 0;			}		}				private function setPan(pan:Number):void 		{        	var transform:SoundTransform = wall_channel.soundTransform;        	transform.pan = pan;        	wall_channel.soundTransform = transform;        }				private function brickSoundComplete(e:Event):void		{			active_brick_sounds.splice(active_brick_sounds.length-1,1);		}				private function oneUp()		{			if (one_up.alpha > 0)			{				one_up.y--;				one_up.alpha -= .025;			}			else			{				display_one_up = false;				if (one_up && parent.contains(one_up))				{					removeChild(one_up);				}			}		}				private function updateTopText()		{			score_text.text = "Score: " + currentScore;				score_text.setTextFormat(top_text_format);			lives_text.text = "Lives: " + current_lives;			lives_text.setTextFormat(top_text_format);			level_text.text =  "Level: " + level;			level_text.setTextFormat(top_text_format);		}				private function createLevel(level)		{							display_level_header_text = "fade_in";						// default sounds						var paddle1_sound:Sound = new paddle1();			var paddle2_sound:Sound = new paddle2();			var wall1_sound:Sound = new wall_bounce();			var serve1_sound:Sound = new serve1();			var serve2_sound:Sound = new serve2();			var serve3_sound:Sound = new serve3();			var death1_sound:Sound = new death1();			var death2_sound:Sound = new death2();			var brick1_sound:Sound = new brick1();			var extra_life_sound:Sound = new extra_life();						level_paddle_sounds = [paddle1_sound,paddle2_sound];			level_brick_sounds = [brick1_sound];			level_wall_sounds = [wall1_sound];			level_death_sounds = [death1_sound,death2_sound];			level_serve_sounds = [serve1_sound,serve2_sound,serve3_sound];			level_extra_life_sounds = [extra_life_sound];						level_complete = false;						active_brick_sounds = new Array;						should_regenerate = false;						finale_activated = false;						regenerate_list = new Array;			future_regenerate_list = new Array;			future_bricks_to_fade_out = new Array;						number_per_speed_increase = 20;						var room_color:uint;			var plot_list:Array;			var line_style_list = new Array;			var color_list:Array;			var colors_for_rows:Array;			var pattern:String;			var level_name_text:String;			if (channel)			{				channel.stop();			}						if (ball && parent.contains(ball))			{				removeChild(ball);			}						if (guide && parent.contains(guide))		  	{				removeChild(guide);			}						if (level == 1)			{				display_level_pad = false;				level_speed = 5;				bricks_per_row = 10;				maximum_bricks_per_row = 10;				numBricks = 10;				brickHeight = 15;				ballRadius = 5;				ceiling_height = 60;				level_name_text = "Easy Street";				room_color = 0x2c3453;				colors_for_rows = [["0x3346cd","0xffffff"]];				line_style_list = ["0x333333"];				ball_max_speed = 10;			}						if (level == 2)			{				display_level_pad = false;				level_speed = 6;					bricks_per_row = 10;				maximum_bricks_per_row = 10;				numBricks = 40;				brickHeight = 15;				ballRadius = 5;				ceiling_height = 45;				level_name_text = "Traditional Trails";				room_color = 0x4a2e1a;				colors_for_rows = ["0x00ff00","0xaff00ff","0xa00ffff","0xffff00"];				line_style_list = ["0x000000"];				ball_max_speed = 10;			}			else if (level == 3)			{				display_level_pad = true;				level_speed = 5;					bricks_per_row = 11;				maximum_bricks_per_row = 13;				numBricks = 85;				brickHeight = 30;				ballRadius = 5;				ceiling_height = 50;				level_name_text = "Space Invaders!";				plot_list = [2,8,14,18,									   24,25,26,27,28,29,30,									   34,35,37,38,39,41,42,									   44,45,46,47,48,49,50,51,52,53,54,									   55,57,58,59,60,61,62,63,65,									   66,68,74,76,									   80,81,83,84];				colors_for_rows = ["0x00FF00"];				line_style_list = ["0x000000"];				room_color = 0x47cc47;				ball_max_speed = 10;								var invaders_brick_sound:Sound = new invaders_brick();				var invaders_paddle_sound:Sound = new invaders_paddle();								level_paddle_sounds = [invaders_paddle_sound];				level_brick_sounds = [invaders_brick_sound];								channel = invaders_ambience_sound.play(0,999);						}						else if (level == 4)			{				display_level_pad = false;				level_speed = 3;					bricks_per_row = 5;				maximum_bricks_per_row = 5;				numBricks = 25;				brickHeight = 30;				ballRadius = 65;				ceiling_height = 25;				level_name_text = "Beach Ball Island";				colors_for_rows = [["0x10eaf8","0x000000"],["0x108df8","0x000000"],["0x1067f8","0x000000"],["0x1036f8","0x000000"],["0x06247a","0x000000"]];				line_style_list = [["0x10eaf8","0x054c50"],["0x108df8","0x042644"],["0x1067f8","0x041c44"],["0x1036f8","0x040d3e"],["0x06247a","0x01091e"]];				room_color = 0xf0ed9b;				number_per_speed_increase = 10;				ball_max_speed = 10;								var beach_paddle1_sound:Sound = new beach_paddle1();				var beach_paddle2_sound:Sound = new beach_paddle2();				var beach_brick1_sound:Sound = new beach_brick1();				var beach_brick2_sound:Sound = new beach_brick2();				var beach_brick3_sound:Sound = new beach_brick3();				var beach_brick4_sound:Sound = new beach_brick4();								level_paddle_sounds = [beach_paddle1_sound,beach_paddle2_sound];				level_brick_sounds = [beach_brick1_sound,beach_brick2_sound,beach_brick3_sound,beach_brick4_sound];								channel = beach_ambience_sound.play(0,999);			}									if (level == 5)			{				display_level_pad = false;				level_speed = 7;					bricks_per_row = 10;				maximum_bricks_per_row = 10;				numBricks = 60;				brickHeight = 15;				ballRadius = 5;				ceiling_height = 65;				level_name_text = "2600 Memories";				room_color = 0x6f686f;				colors_for_rows = ["0xa0475f","0xa03730","0xa05830","0xa09030","0x30a730","0x3040a0"];				ball_max_speed = 10;								var brick1_2600_sound:Sound = new brick_2600_1();						var brick2_2600_sound:Sound = new brick_2600_2();				var brick3_2600_sound:Sound = new brick_2600_3();				var brick4_2600_sound:Sound = new brick_2600_4();				var paddle_2600_sound:Sound = new paddle_2600();				var wall_2600_sound:Sound = new wall_2600();										level_paddle_sounds = [paddle_2600_sound];				level_brick_sounds = [brick1_2600_sound,brick2_2600_sound,brick3_2600_sound,brick4_2600_sound];				level_wall_sounds = [wall_2600_sound];			}						else if (level == 6)			{				display_level_pad = true;				level_speed = 5;					bricks_per_row = 18;				maximum_bricks_per_row = 30;				numBricks = 108;				brickHeight = 50;				ballRadius = 5;				ceiling_height = 60;				level_name_text = "Purple Piano Paradise";				plot_list = [							 0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,							 18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,							 36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,							 54,55,56,57,58,60,61,62,63,64,65,67,68,69,70,71,							 72,73,74,75,76,78,79,80,81,82,83,85,86,87,88,89,							 90,91,92,93,94,96,97,98,99,100,101,103,104,105,106,107							 ];											color_list = [[0,"0x200646"],[4,"0x000000"],[7,"0x200646"],[11,"0x000000"],[14,"0x200646"],							  [18,"0x301463"],[22,"0x000000"],[25,"0x301463"],[29,"0x000000"],[32,"0x301463"],							  [36,"0x482a8d"],[40,"0x000000"],[43,"0x482a8d"],[47,"0x000000"],[50,"0x482a8d"],							  [54,"0x5f3eb9"],							  [72,"0x6a49ce"],							  [90,"0x7e5af1"],							  ];				line_style_list = ["0x000000",["0x000000","0x222222"]];								var piano_brick1_sound:Sound = new piano_brick_1();				var piano_brick2_sound:Sound = new piano_brick_2();				var piano_brick3_sound:Sound = new piano_brick_3();				var piano_brick4_sound:Sound = new piano_brick_4();				var piano_brick5_sound:Sound = new piano_brick_5();				var piano_brick6_sound:Sound = new piano_brick_6();								level_brick_sounds = [piano_brick1_sound,piano_brick2_sound,piano_brick3_sound,piano_brick4_sound,piano_brick5_sound,piano_brick6_sound];								room_color = 0x613eff;				ball_max_speed = 10;			}						else if (level == 7)			{				display_level_pad = true;				level_speed = 15;							bricks_per_row = 2;				maximum_bricks_per_row = 2;				numBricks = 12;				brickHeight = 30;				ballRadius = 5;				ceiling_height = 0;				level_name_text = "Bubble Gum Dreams";				colors_for_rows = [["0xe964fd","0xf3b0fd"]];				line_style_list = ["0xf46df9"];				room_color = 0xf5b0ff;				ball_max_speed = 20;			}						else if (level == 8)			{				display_level_pad = true;				level_speed = 7;										bricks_per_row = 8;				maximum_bricks_per_row = 10;				numBricks = 150;				brickHeight = 15;				ballRadius = 5;				ceiling_height = 50;				level_name_text = "Unfinished Business";				plot_list = new Array;				for (var plot:int = 0; plot < numBricks; plot++)				{					if (Math.round(Math.random()*1) == 1)					{						plot_list.push(plot);					}				}				colors_for_rows = [["0xff873e","0x000000"]];				line_style_list = ["0x5b2c06"];				room_color = 0xff873e;				ball_max_speed = 20;			}						else if (level == 9)			{				display_level_pad = true;				level_speed = 7;					bricks_per_row = 14;				maximum_bricks_per_row = 24;				numBricks = 182;				brickHeight = 25;				ballRadius = 25;				ceiling_height = 35;				level_name_text = "Pac-Man Fever";				plot_list = [							  5,6,7,8,							  17,18,19,20,21,22,23,24,							  30,31,32,33,34,35,36,37,38,39,							  43,44,45,46,47,48,49,50,51,52,53,54,							  57,58,59,60,61,62,63,64,65,66,67,68,							  71,72,73,74,75,76,77,78,79,80,81,82,							  84,85,86,87,88,89,90,91,92,93,94,95,96,97,							  98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,							  113,114,115,116,117,118,119,120,121,122,123,124,125,126,							  127,128,129,130,131,132,133,134,135,136,137,138,139,140,							  141,142,143,144,145,146,147,148,149,150,151,152,153,							  154,155,156,157,159,160,161,162,164,165,166,167,							  169,170,174,175,179,180							 							 ];								color_list = [[0,"0xff0000"],										 [46,"0xffffff"],[48,"0xff0000"],[52,"0xffffff"],[54,"0xff0000"],										 [59,"0xffffff"],[63,"0xff0000"],[65,"0xffffff"],										 [71,"0xff0000"],[73,"0xffffff"],[75,"0x000000"],[77,"0xff0000"],[79,"0xffffff"],[81,"0x000000"],										 [84,"0xff0000"],[87,"0xffffff"],[89,"0x000000"],[91,"0xff0000"],[93,"0xffffff"],[95,"0x000000"],[97,"0xff0000"],										 [102,"0xffffff"],[104,"0xff0000"],[108,"0xffffff"],[110,"0xff0000"]];										 				line_style_list = [["0xff0000","0x900000"],["0xffffff","0x999999"],["0x000000","0x222222"]];								room_color = 0x0819fb;				ball_max_speed = 10;								var pacman_brick1_sound:Sound = new pacman_brick1();				var pacman_brick2_sound:Sound = new pacman_brick2();					var pacman_brick3_sound:Sound = new pacman_brick3();				var pacman_brick4_sound:Sound = new pacman_brick4();				var pacman_brick5_sound:Sound = new pacman_brick5();				var pacman_song_sound:Sound = new pacman_song();					var pacman_death_sound:Sound = new pacman_death();								level_death_sounds = [pacman_death_sound];				level_brick_sounds = [pacman_brick1_sound,pacman_brick2_sound,pacman_brick3_sound,pacman_brick4_sound,pacman_brick5_sound];				channel = pacman_song_sound.play(0,0);						}						else if (level == 10)			{				display_level_pad = true;				level_speed = 8;					bricks_per_row = 10;				maximum_bricks_per_row = 10;				numBricks = 60;				brickHeight = 60;				ballRadius = 5;				ceiling_height = 0;				level_name_text = "Challenging Checkers";				pattern = "checker"				color_list = [["0x000000"],["0xffffff","0x666666"]];				room_color = 0x000000;				ball_max_speed = 15;			}						else if (level == 11)			{				level_speed = 10;						bricks_per_row = 36;				maximum_bricks_per_row = 38;				numBricks = 1223;				brickHeight = 12;				ballRadius = 15;				ceiling_height = 5;				plot_list = [							 17,18,							 51,52,53,54,55,56,							 85,86,87,88,89,90,91,92,93,94,							 119,120,121,122,123,124,125,126,127,128,129,130,131,132,							 153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,170,							 							 216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,							 259,260,261,262,277,278,279,280,							 289,290,291,296,297,298,299,301,302,303,304,305,306,307,308,309,310,312,313,314,315,320,321,322,							 325,326,327,329,330,333,334,335,336,347,348,349,350,353,354,356,357,358,							 361,362,363,365,366,370,371,372,373,374,375,376,379,380,381,382,383,384,385,389,390,392,393,394,							 397,398,399,407,408,409,410,411,412,415,416,417,418,419,420,428,429,430,							 468,469,470,471,472,473,474,475,476,477,478,479,480,481,482,483,484,485,486,487,488,489,490,491,492,493,494,495,496,497,498,499,500,501,502,503,														 541,542,543,556,557,558,559,572,573,574,							 577,578,579,608,609,610,							 613,614,615,644,645,646,							 649,650,651,680,681,682,							 685,686,687,716,717,718,							 721,722,723,752,753,754,							 757,758,759,788,789,790,							 793,794,795,824,825,826,							 829,830,831,860,861,862,							 865,866,867,896,897,898,							 901,902,903,932,933,934,							 937,938,939,968,969,970,							 973,974,975,1004,1005,1006,							 1009,1010,1011,1040,1041,1042,							 1045,1046,1047,1076,1077,1078,							 1081,1082,1083,1112,1113,1114,							 1117,1118,1119,1120,1147,1148,1149,1150,							 1153,1154,1155,1156,1157,1182,1183,1184,1185,1186,							 1189,1190,1191,1192,1193,1194,1217,1218,1219,1220,1221,1222							 ];				line_style_list = ["0x000000"];				level_name_text = "Regenerating Recognizer";				colors_for_rows = [["0xff0000","0x000000"],["0xfd1817","0x000000"],["0xf81717","0x000000"],["0xf41617","0x000000"],["0xf41617","0x000000"],["0xe51515","0x000000"],["0xde1515","0x000000"],["0xd81314","0x000000"],["0xd21312","0x000000"],["0xcb1212","0x000000"],["0xc41111","0x000000"],["0xb81010","0x000000"],["0xa80f0e","0x000000"],["0xa10e0e","0x000000"],["0x980d0c","0x000000"],["0x910b0b","0x000000"],["0x880a0b","0x000000"],["0x830a0a","0x000000"],["0x7a0909","0x000000"],["0x720809","0x000000"],["0x6b0708","0x000000"],["0x640706","0x000000"],["0x5e0606","0x000000"],["0x590506","0x000000"],["0x500504","0x000000"],["0x4b0404","0x000000"],["0x450303","0x000000"],["0x3f0203","0x000000"],["0x3a0202","0x000000"],["0x340101","0x000000"],["0x310101","0x000000"],["0x290101","0x000000"],["0x250101","0x000000"],["0x240000","0x000000"]];				color_list = [[53,"0xfffcb2"],[54,"0xfffcb2"]];								room_color = 0xf30924;				ball_max_speed = 30;				number_per_speed_increase = 12;				should_regenerate = true;								var tron_brick1_sound:Sound = new tron_brick1();				var tron_brick2_sound:Sound = new tron_brick2();				var tron_brick3_sound:Sound = new tron_brick3();				var tron_brick4_sound:Sound = new tron_brick4();				var tron_brick5_sound:Sound = new tron_brick5();				var tron_brick6_sound:Sound = new tron_brick6();				var tron_brick7_sound:Sound = new tron_brick7();				var tron_paddle1_sound:Sound = new tron_paddle1();				var tron_paddle2_sound:Sound = new tron_paddle2();				var tron_paddle3_sound:Sound = new tron_paddle3();									level_brick_sounds = [tron_brick1_sound,tron_brick2_sound,tron_brick3_sound,tron_brick4_sound,tron_brick5_sound,tron_brick6_sound,tron_brick7_sound];			  	level_paddle_sounds = [tron_paddle1_sound,tron_paddle2_sound,tron_paddle3_sound];							channel = recognizer_ambience_sound.play(0,999);				}						brickWidth = (playfieldWidth - (wall_width * 2)) / maximum_bricks_per_row;						bricks = new Array();						brick_x_start = ((wall_width + brickWidth / 2) is uint) ? (wall_width + brickWidth / 2) : (wall_width + brickWidth / 2)+1;			brick_y_start = ceiling + ceiling_height + (brickHeight / 2) + (wall_width / 2);						// to compensate for the first i%(bricks_per_row) equalling 0			brick_y_start -= brickHeight;			var row_color:int = -1;						var x_position:int;			var y_position:int = brick_y_start;			var the_offset:int = 0;			var brick_start_for_array:int;			var color_index:int = 0;			var current_color:uint;						if (bricks_per_row != maximum_bricks_per_row)			{				the_offset = brickWidth * ((maximum_bricks_per_row - bricks_per_row) / 2);			}			for( var i:uint = 0; i < numBricks; i++ )			{				if (i%(bricks_per_row) == 0) 				{					row_color++;					y_position += brickHeight;					x_position = brick_x_start + the_offset;					brick_start_for_array = x_position - (brickWidth / 2);				}								if (colors_for_rows && row_color > colors_for_rows.length-1)				{					row_color = 0;				}								var brickSprite = new Sprite();				brickSprite.x = x_position;				brickSprite.y = y_position;								x_position += brickWidth;								if (pattern == "checker" && color_list)				{					var checker_alternate:Boolean;					var checker_color:Array = new Array;									if (i%(bricks_per_row) == 0) 					{						checker_alternate = checker_alternate ? false : true;					}										if (i%2 == 0 && checker_alternate)					{						checker_color = color_list[0];					}					else if (i%2 !=0 && checker_alternate)					{						checker_color = color_list[1];					}					else if (i%2 == 0 && !checker_alternate)					{						checker_color = color_list[1];					}					else if (i%2 !=0 && !checker_alternate)					{						checker_color = color_list[0];					}										if (checker_color.length == 1)					{						brickSprite.graphics.beginFill(checker_color);					}					else					{						brickSprite.graphics.beginGradientFill(GradientType.LINEAR, checker_color, [1, 1], [115, 155]);					}				}				else 				{					if (colors_for_rows)					{							if (colors_for_rows[row_color].length == 2 )						{							brickSprite.graphics.beginGradientFill(GradientType.LINEAR, colors_for_rows[row_color], [1, 1], [115, 155]);							current_color = colors_for_rows[row_color][0];						}						else						{							current_color = colors_for_rows[row_color];							brickSprite.graphics.beginFill(current_color);						}					}										if (color_list)					{						if (color_index <= color_list.length-1 && color_list[color_index][0] == i)						{							current_color = color_list[color_index][1];							color_index++;						}							brickSprite.graphics.beginFill(current_color);					}				}												if (line_style_list)				{					if (line_style_list.length == 1)					{						brickSprite.graphics.lineStyle(1,line_style_list[0]);					}					else					{						for (var the_color:int = 1; the_color < line_style_list.length; the_color++)						{							if (line_style_list[the_color][0] == current_color)							{								brickSprite.graphics.lineStyle(1,line_style_list[the_color][1]);							}							else							{								brickSprite.graphics.lineStyle(1,line_style_list[0]);							}						}					}				}								brickSprite.graphics.drawRect(-brickHeight/2, -brickWidth/2, brickHeight,  brickWidth);				brickSprite.graphics.endFill();				brickSprite.rotation = 90;								if (!plot_list || plot_list && plot_list.indexOf(i) != -1)				{					bricks.push( brickSprite );					addChildAt(brickSprite,1);				}			}						real_number_of_bricks = bricks.length;						last_brick_row = brick_y_start + (brickHeight * (numBricks / bricks_per_row)) + brickHeight / 2;					 			createBall();			createWalls(room_color);			createGuide();			updateTopText();				var level_header_text = "Level " + level;			textEffect(level_header_text, level_name_text);		}				private function createBall()		{				ball = new Shape();				ball.graphics.beginFill(0xffffff);						ball.graphics.drawCircle(0, 0, ballRadius);				ball.graphics.endFill();				ball.y = bat.y - batHeight / 2 - ballRadius;						if (!parent.contains(ball))			{				addChild(ball);								// add glow to ball				glow.color=0xFFFFFF;				glow.strength=2;				glow.inner=false;				glow.blurY=5;				glow.blurX=5;				ball.filters=[glow];			}		}				private function createWalls(room_color)		{			var walls:Array = [wall_one, wall_two, ceiling_top, ceiling_floor];			for (var wall in walls)			{				if (walls[wall] && parent.contains(walls[wall]))				{					removeChild(walls[wall]);				}			}						wall_one = new Shape();				wall_two = new Shape();			ceiling_top = new Shape();			ceiling_floor = new Shape();			var wall_two_start:int = line_style_list ? (((brickWidth * maximum_bricks_per_row) + wall_width + wall_width / 2) + 1) : ((brickWidth * maximum_bricks_per_row) + wall_width + wall_width / 2);						wall_one.graphics.moveTo(0,0);			wall_one.graphics.lineStyle(wall_width, room_color, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);			wall_one.graphics.lineTo(0, playfieldHeight - batHeight);						wall_two.graphics.moveTo(0,0);			wall_two.graphics.lineStyle(wall_width, room_color, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);			wall_two.graphics.lineTo(0, playfieldHeight - batHeight);					ceiling_top.graphics.moveTo(wall_width / 2, wall_width / 2);			ceiling_top.graphics.lineStyle(wall_width, room_color, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);			ceiling_top.graphics.lineTo(wall_two_start, wall_width / 2);			ceiling_floor.graphics.moveTo(wall_width / 2, ceiling);			ceiling_floor.graphics.lineStyle(wall_width, room_color, 1, false, LineScaleMode.NORMAL, CapsStyle.SQUARE);			ceiling_floor.graphics.lineTo(wall_two_start, ceiling);						wall_one.x = wall_width / 2;			wall_one.y = wall_width / 2;			wall_two.x = wall_two_start; 			wall_two.y = wall_width / 2;						addChild(wall_one);			addChild(wall_two);			addChild(ceiling_top);			addChild(ceiling_floor);		}				private function finale()		{			if (channel)			{				channel.stop();			}						createWalls(0x000000);						removeLevelText();								var game_over_format:TextFormat = new TextFormat();						game_over_text.text = "Congratulations! YOU WON!";			game_over_format.size = 20;			game_over_format.letterSpacing = 10;			game_over_format.font = level_font.fontName;					game_over_text.setTextFormat(game_over_format);			game_over_text.x = centerText(game_over_text);			game_over_text.y = 240;						game_over = true;						channel = applause_sound.play(0,0);						if (!parent.contains(game_over_text))			{				addChild(game_over_text);			}						if (parent.contains(ball))			{				removeChild(ball);			}						display_level_header_text = null;			level_complete = false;			finale_activated = true;		}			}}